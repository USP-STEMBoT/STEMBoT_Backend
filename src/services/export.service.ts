// FILE PATH: src/services/export.service.ts
// FILE DESCRIPTION: Service for exporting data to various formats

import ExcelJS from "exceljs";
import { IChatHistoryRepository } from "../repositories/interfaces/IChatHistoryRepository";
import { ChatHistoryEntity } from "../entities/chat-history.entity";

export class ExportService {
  constructor(private chatHistoryRepository: IChatHistoryRepository) {}

  /**
   * Export chat history to Excel format
   */
  async exportChatHistoryToExcel(
    startDate?: Date,
    endDate?: Date,
  ): Promise<Buffer> {
    // Get chat history data
    const chatHistory = await this.chatHistoryRepository.findByDateRange(
      startDate,
      endDate,
    );

    // Create a new workbook
    const workbook = new ExcelJS.Workbook();

    // Add properties to the workbook
    workbook.creator = "STEMPBoT Admin";
    workbook.lastModifiedBy = "STEMPBoT Admin";
    workbook.created = new Date();
    workbook.modified = new Date();
    workbook.lastPrinted = new Date();

    // Add a worksheet
    const worksheet = workbook.addWorksheet("Chat History");

    // Define columns
    worksheet.columns = [
      { header: "ID", key: "id", width: 36 },
      { header: "Question", key: "question", width: 50 },
      { header: "Answer", key: "answer", width: 50 },
      { header: "Source", key: "source", width: 15 },
      { header: "Created At", key: "createdAt", width: 20 },
      { header: "Question Length", key: "questionLength", width: 15 },
      { header: "Answer Length", key: "answerLength", width: 15 },
    ];

    // Add header styling
    const headerRow = worksheet.getRow(1);
    headerRow.font = { bold: true, color: { argb: "FFFFFFFF" } };
    headerRow.fill = {
      type: "pattern",
      pattern: "solid",
      fgColor: { argb: "FF01434A" }, // USPT Dark Teal
    };
    headerRow.alignment = { vertical: "middle", horizontal: "center" };
    headerRow.height = 30;

    // Add data rows
    chatHistory.forEach((chat, index) => {
      const row = worksheet.addRow({
        id: chat.id,
        question: chat.question,
        answer: chat.answer,
        source: chat.source.toUpperCase(),
        createdAt: chat.createdAt.toISOString(),
        questionLength: chat.question.length,
        answerLength: chat.answer.length,
      });

      // Alternate row colors for better readability
      if (index % 2 === 0) {
        row.fill = {
          type: "pattern",
          pattern: "solid",
          fgColor: { argb: "FFF0F4F5" }, // Light gray-blue
        };
      }

      // Center align source column
      row.getCell("source").alignment = { horizontal: "center" };

      // Right align length columns
      row.getCell("questionLength").alignment = { horizontal: "right" };
      row.getCell("answerLength").alignment = { horizontal: "right" };
    });

    // Auto-fit columns
    worksheet.columns.forEach((column) => {
      if (column.width) {
        column.width = Math.min(column.width || 0, 100);
      }
    });

    // Add a summary sheet
    const summarySheet = workbook.addWorksheet("Summary");

    // Add summary data
    summarySheet.columns = [
      { header: "Metric", key: "metric", width: 30 },
      { header: "Value", key: "value", width: 20 },
    ];

    const summaryHeader = summarySheet.getRow(1);
    summaryHeader.font = { bold: true, color: { argb: "FFFFFFFF" } };
    summaryHeader.fill = {
      type: "pattern",
      pattern: "solid",
      fgColor: { argb: "FF01434A" },
    };
    summaryHeader.alignment = { vertical: "middle", horizontal: "center" };

    const totalChats = chatHistory.length;
    const cacheChats = chatHistory.filter((c) => c.source === "cache").length;
    const openaiChats = chatHistory.filter((c) => c.source === "openai").length;
    const cacheHitRate =
      totalChats > 0 ? ((cacheChats / totalChats) * 100).toFixed(2) : "0.00";

    const summaryData = [
      { metric: "Total Conversations", value: totalChats },
      { metric: "Cache Responses", value: cacheChats },
      { metric: "OpenAI Responses", value: openaiChats },
      { metric: "Cache Hit Rate", value: `${cacheHitRate}%` },
      {
        metric: "Date Range",
        value:
          startDate && endDate
            ? `${startDate.toISOString().split("T")[0]} to ${endDate.toISOString().split("T")[0]}`
            : "All Time",
      },
      { metric: "Report Generated", value: new Date().toISOString() },
      { metric: "Generated By", value: "STEMPBoT Admin Dashboard" },
    ];

    summaryData.forEach((item, index) => {
      const row = summarySheet.addRow(item);
      if (index % 2 === 0) {
        row.fill = {
          type: "pattern",
          pattern: "solid",
          fgColor: { argb: "FFF0F4F5" },
        };
      }
    });

    // Generate Excel file as buffer
    const buffer = await workbook.xlsx.writeBuffer();
    return Buffer.from(buffer);
  }

  /**
   * Export chat history to CSV format
   */
  async exportChatHistoryToCSV(
    startDate?: Date,
    endDate?: Date,
  ): Promise<string> {
    const chatHistory = await this.chatHistoryRepository.findByDateRange(
      startDate,
      endDate,
    );

    // CSV headers
    const headers = [
      "ID",
      "Question",
      "Answer",
      "Source",
      "Created At (UTC)",
      "Question Length",
      "Answer Length",
    ];

    // CSV rows
    const rows = chatHistory.map((chat) => [
      `"${chat.id}"`,
      `"${chat.question.replace(/"/g, '""')}"`, // Escape quotes
      `"${chat.answer.replace(/"/g, '""')}"`, // Escape quotes
      `"${chat.source}"`,
      `"${chat.createdAt.toISOString()}"`,
      `"${chat.question.length}"`,
      `"${chat.answer.length}"`,
    ]);

    // Add summary section
    const totalChats = chatHistory.length;
    const cacheChats = chatHistory.filter((c) => c.source === "cache").length;
    const openaiChats = chatHistory.filter((c) => c.source === "openai").length;
    const cacheHitRate =
      totalChats > 0 ? ((cacheChats / totalChats) * 100).toFixed(2) : "0.00";

    const summary = [
      "\n\n=== SUMMARY ===",
      `Total Conversations: ${totalChats}`,
      `Cache Responses: ${cacheChats}`,
      `OpenAI Responses: ${openaiChats}`,
      `Cache Hit Rate: ${cacheHitRate}%`,
      `Date Range: ${
        startDate && endDate
          ? `${startDate.toISOString().split("T")[0]} to ${endDate.toISOString().split("T")[0]}`
          : "All Time"
      }`,
      `Report Generated: ${new Date().toISOString()}`,
      `Generated By: STEMPBoT Admin Dashboard`,
    ];

    return [
      headers.join(","),
      ...rows.map((row) => row.join(",")),
      ...summary,
    ].join("\n");
  }

  /**
   * Export chat history to JSON format
   */
  async exportChatHistoryToJSON(
    startDate?: Date,
    endDate?: Date,
  ): Promise<any> {
    const chatHistory = await this.chatHistoryRepository.findByDateRange(
      startDate,
      endDate,
    );

    const totalChats = chatHistory.length;
    const cacheChats = chatHistory.filter((c) => c.source === "cache").length;
    const openaiChats = chatHistory.filter((c) => c.source === "openai").length;
    const cacheHitRate =
      totalChats > 0 ? ((cacheChats / totalChats) * 100).toFixed(2) : "0.00";

    return {
      metadata: {
        reportName: "STEMPBoT Chat History Export",
        generatedAt: new Date().toISOString(),
        generatedBy: "STEMPBoT Admin Dashboard",
        dateRange:
          startDate && endDate
            ? {
                start: startDate.toISOString(),
                end: endDate.toISOString(),
              }
            : "All Time",
        summary: {
          totalConversations: totalChats,
          cacheResponses: cacheChats,
          openaiResponses: openaiChats,
          cacheHitRate: `${cacheHitRate}%`,
        },
      },
      data: chatHistory.map((chat) => ({
        id: chat.id,
        question: chat.question,
        answer: chat.answer,
        source: chat.source,
        createdAt: chat.createdAt.toISOString(),
        questionLength: chat.question.length,
        answerLength: chat.answer.length,
      })),
    };
  }
}
